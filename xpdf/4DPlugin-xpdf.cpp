/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-xpdf.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : xpdf
 #	author : miyako
 #	2020/04/19
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-xpdf.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- xpdf
                
            case 1 :
                XPDF_Get_text(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

static void write_to_stream(void *stream, const char *text, int len) {
    
    C_BLOB *buf = (C_BLOB *)stream;

    buf->addBytes((const uint8_t *)text, len);
    
}

void XPDF_Get_text(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    
    ob_set_b(status, L"success", false);
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    CUTF8String filePath;
    Param1.copyPath(&filePath);
    
    int firstPage = 1;
    int lastPage  = 0;
    
    GBool tableLayout  = gFalse;
    GBool physLayout   = gFalse;
    GBool simpleLayout = gFalse;
    GBool linePrinter  = gFalse;
    GBool rawOrder     = gFalse;
    
    GBool noPageBreaks = gFalse;
        
    GString *ownerPW = NULL;
    GString *userPW  = NULL;
    
    double marginLeft   = 0;
    double marginRight  = 0;
    double marginTop    = 0;
    double marginBottom = 0;
    
    double fixedPitch       = 0; /* table,physical,line */
    double fixedLineSpacing = 0; /* line */
    
    GBool clipText = gFalse;
    GBool discardDiagonalText = gFalse;
    
    if(options){
    
        CUTF8String _layout, _ownerPassword, _userPassword;
        
        if(ob_is_defined(options, L"start")) {
            
            int _firstPage = ob_get_n(options, L"start");
            if(_firstPage > 0) {
                firstPage = _firstPage;
            }
        }
        
        if(ob_is_defined(options, L"end")) {
            
            lastPage = ob_get_n(options, L"end");

        }
        
        if(ob_get_s(options, L"layout", &_layout)) {
            
            if(_layout == (const uint8_t *)"table") {
                tableLayout = gTrue;
            }else
            if(_layout == (const uint8_t *)"physical") {
                physLayout = gTrue;
            }else
            if(_layout == (const uint8_t *)"simple") {
                simpleLayout = gTrue;
            }else
            if(_layout == (const uint8_t *)"line") {
                linePrinter = gTrue;
            }else
            if(_layout == (const uint8_t *)"raw") {
                rawOrder = gTrue;
            }
            
        }
        
        if(ob_is_defined(options, L"noPageBreaks")) {
            noPageBreaks = ob_get_b(options, L"noPageBreaks");
        }
        
        if(ob_get_s(options, L"ownerPassword", &_ownerPassword)) {
            ownerPW = new GString((const char *)_ownerPassword.c_str());
        }
        
        if(ob_get_s(options, L"userPassword",  &_userPassword)) {
            userPW  = new GString((const char *)_userPassword.c_str());
        }
        
        if(ob_is_defined(options, L"marginLeft")) {
            marginLeft = ob_get_n(options, L"marginLeft");
        }

        if(ob_is_defined(options, L"marginRight")) {
            marginRight = ob_get_n(options, L"marginRight");
        }
        
        if(ob_is_defined(options, L"marginTop")) {
            marginTop = ob_get_n(options, L"marginTop");
        }
        
        if(ob_is_defined(options, L"marginBottom")) {
            marginBottom = ob_get_n(options, L"marginBottom");
        }
        
        if(ob_is_defined(options, L"fixedPitch")) {
            fixedPitch = ob_get_n(options, L"fixedPitch");
        }

        if(ob_is_defined(options, L"fixedLineSpacing")) {
            fixedLineSpacing = ob_get_n(options, L"fixedLineSpacing");
        }

        if(ob_is_defined(options, L"clipText")) {
            clipText = ob_get_b(options, L"clipText");
        }

        if(ob_is_defined(options, L"discardDiagonalText")) {
            discardDiagonalText = ob_get_b(options, L"discardDiagonalText");
        }

    }
    
    PDFDoc *doc;
    TextOutputControl textOutControl;
    TextOutputDev *textOut;
    UnicodeMap *uMap;


    int exitCode;
        
    exitCode = 99;
        
    
    globalParams = new GlobalParams("");
    globalParams->setTextEncoding("UTF-8");

    if ((uMap = globalParams->getTextEncoding())) {
        
        if (noPageBreaks) {
            globalParams->setTextPageBreaks(gFalse);
        }
        
        globalParams->setErrQuiet(gTrue);
        
        doc = new PDFDoc((char *)filePath.c_str(), ownerPW, userPW);
        
        if (userPW) {
            delete userPW;
        }
        
        if (ownerPW) {
            delete ownerPW;
        }

        if (doc->isOk()) {

            if (doc->okToCopy()) {

                if (lastPage < 1 || lastPage > doc->getNumPages()) {
                    lastPage = doc->getNumPages();
                }
                
                if (tableLayout) {
                    textOutControl.mode = textOutTableLayout;
                    textOutControl.fixedPitch = fixedPitch;
                } else if (physLayout) {
                    textOutControl.mode = textOutPhysLayout;
                    textOutControl.fixedPitch = fixedPitch;
                } else if (simpleLayout) {
                    textOutControl.mode = textOutSimpleLayout;
                } else if (linePrinter) {
                    textOutControl.mode = textOutLinePrinter;
                    textOutControl.fixedPitch = fixedPitch;
                    textOutControl.fixedLineSpacing = fixedLineSpacing;
                } else if (rawOrder) {
                    textOutControl.mode = textOutRawOrder;
                } else {
                    textOutControl.mode = textOutReadingOrder;
                }
                
                textOutControl.marginLeft   = marginLeft;
                textOutControl.marginRight  = marginRight;
                textOutControl.marginTop    = marginTop;
                textOutControl.marginBottom = marginBottom;
                
                textOutControl.insertBOM = gFalse;
                
                textOutControl.clipText = clipText;
                textOutControl.discardDiagonalText = discardDiagonalText;
                                
                C_BLOB buf;
                
                textOut = new TextOutputDev(write_to_stream, &buf, &textOutControl);
                
                if (textOut->isOk()) {
                    doc->displayPages(textOut,
                                      firstPage,
                                      lastPage,
                                      72,
                                      72,
                                      0,
                                      gFalse, gTrue, gFalse);
                    
                    std::string text = std::string((const char *)buf.getBytesPtr(), buf.getBytesLength());
                    
                    ob_set_s(status, L"text", text.c_str());
                    ob_set_b(status, L"success", true);
                    
                } else {

                    ob_set_s(options, L"errorMessage", "failed to create output");
                    
                    delete textOut;

                }
                
                delete textOut;
                
            }else{
                ob_set_s(options, L"errorMessage", "copy is not allowed");
            }
            
        }else{
            ob_set_n(options, L"error", doc->getErrorCode());
            ob_set_s(options, L"errorMessage", "failed to open pdf");
        }

        delete doc;
        uMap->decRefCnt();
    }
    
    delete globalParams;
    
    ob_set_b(status, L"success", false);
    
    PA_ReturnObject(params, status);
}
